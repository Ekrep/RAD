<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <link rel="icon" href="data:,">
  <title>%UNITY_WEBGL_NAME%</title>
  %UNITY_WEBGL_HEAD_HTML%
  <style>html,body,#unity-container{margin:0;padding:0;height:100%;}</style>
</head>
<body>
  <div id="unity-container" style="width:100%;height:100%;background:#231F20">
    <canvas id="unity-canvas" tabindex="-1" style="width:100%;height:100%"></canvas>
  </div>

  %UNITY_WEBGL_LOADER_GLUE%

  <!-- MediaPipe + IPD entegrasyonu -->
  <script type="module">
  import { FaceLandmarker, FilesetResolver }
    from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

  const W = 640, H = 480;
  let video, landmarker, receiverName = null, running = false, q = [];

  async function init() {
    video = document.createElement('video');
    video.width=W; video.height=H; video.autoplay=true; video.playsInline=true; video.muted=true;
    document.body.appendChild(video);
    const stream = await navigator.mediaDevices.getUserMedia({ video:{width:W,height:H}, audio:false });
    video.srcObject = stream;

    const fs = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
    landmarker = await FaceLandmarker.createFromOptions(fs, {
      baseOptions: {
        modelAssetPath:
          "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task"
      },
      runningMode: "VIDEO",
      numFaces: 1,
      outputFaceBlendshapes: false,
      outputFacialTransformationMatrixes: false
    });
  }

  function irisRadiusPx(lm,c,r0){
    const cx=lm[c].x*W, cy=lm[c].y*H;
    let s=0; for(let i=r0;i<r0+4;i++){ const px=lm[i].x*W, py=lm[i].y*H; s+=Math.hypot(px-cx,py-cy); }
    return s/4;
  }
  function calibrateMmPerPx(lm){
    const r=irisRadiusPx(lm,468,469), l=irisRadiusPx(lm,473,474);
    const avg=(r+l)/2; return 11.7/(avg*2);
  }
  function ipdPx(lm){
    const r=lm[468], l=lm[473];
    return Math.hypot((l.x-r.x)*W,(l.y-r.y)*H);
  }
  function smooth(v){ if(v==null)return null; q.push(v); if(q.length>10)q.shift(); return q.reduce((a,b)=>a+b,0)/q.length; }

  function sendToUnity(obj){
    const msg = JSON.stringify(obj);
    if (window.unityInstance?.SendMessage) {
      window.unityInstance.SendMessage(receiverName, "OnFace", msg);
    } else if (typeof SendMessage === "function") {
      SendMessage(receiverName, "OnFace", msg);
    }
  }

  async function loop(){
    if(!running || !landmarker){requestAnimationFrame(loop);return;}
    const ts = performance.now();
    if(video.readyState>=2){
      const res = landmarker.detectForVideo(video, ts);
      const f = res?.faceLandmarks?.[0];
      if (f){
        const px = ipdPx(f);
        const mm = px * calibrateMmPerPx(f);
        sendToUnity({ ipdPx: smooth(px), ipdMm: smooth(mm) });
      }
    }
    requestAnimationFrame(loop);
  }

  // Unity'den çağrılacak API
  window.FaceAPI = {
    async start(){ if(!landmarker) await init(); if(!running){ running=true; loop(); } },
    stop(){ running=false; },
    setReceiver(n){ receiverName = n; }
  };
  </script>
</body>
</html>
